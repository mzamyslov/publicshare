<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1, width=device-width" />
  <title>Norway Fylke/Kommuner + Barnehager</title>
  <style>
    html,body,#map{height:100%;margin:0}
    .legend{position:absolute;bottom:12px;left:12px;background:#fff;padding:8px 10px;border:1px solid #ccc;border-radius:8px;font:12px system-ui}
    .ctl{position:absolute;top:12px;left:12px;background:#fff;padding:6px 8px;border:1px solid #ccc;border-radius:8px;font:12px system-ui}
    /* styles for labels over the circles */
    .bh-label{
      position:relative;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
      font-weight:600;
      line-height:1;
      letter-spacing:0.2px;
      color:#111;
      text-align:center;
      transform:translate(-50%,-50%); /* center in the middle of the circle */
      text-shadow:
        -1px -1px 0 #fff,  0 -1px 0 #fff,  1px -1px 0 #fff,
        -1px  0   0 #fff,  1px  0   0 #fff,
        -1px  1px 0 #fff,  0  1px 0 #fff,  1px  1px 0 #fff;
      pointer-events:none; /* passthrough clicks */
    }
    
  </style>
  <script src="metrics.js"></script>
<script defer type="module">
  // ===================== CONFIG =====================
  const CFG = {
    urls: {
      fylke: "./fylke.geojson",
      kommune: "./kommune.geojson",
      barnehager: "./barnehager.json",
    },
    zoom: {
      initial: 5.2,
      showKommunerFrom: 9, // Zoom - begining from this zoom level kommune shown instead of fylke
    },
    opacity: {
      // IMPORTANT: maxOpacity is used for minimum zoom, minOpacity — for max zoom (reducing opacity on zooming in)
      fylke:   { minZoom: 1,  maxZoom: 9,  maxOpacity: 0.95, minOpacity: 0.55 },
      kommune: { minZoom: 9,  maxZoom: 13, maxOpacity: 0.55, minOpacity: 0.0 },
    },
    poly: {
      fylkeStroke: 0.3,
      kommuneStroke: 0.3,
    },
    points: {
      radiusM: 40,
      strokeWeight: 4,
    },
    labels: {
      showFromZoom: 10,  // sterting zoom level for showing barnehage labels
      minPx: 10,         // minimum label size
      maxPx: 18          // maximum label size
    },
    mapStyle: [
      { elementType: "geometry", stylers: [{ color: "#5a5a5a" }] },
      { elementType: "labels.icon", stylers: [{ visibility: "off" }] },
      { elementType: "labels.text.fill", stylers: [{ color: "#f0f0f0" }] },
      { elementType: "labels.text.stroke", stylers: [{ color: "#5a5a5a" }] },
      { featureType: "poi", elementType: "geometry", stylers: [{ color: "#4f4f4f" }] },
      { featureType: "poi.park", elementType: "geometry", stylers: [{ color: "#494949" }] },
      { featureType: "road", elementType: "geometry", stylers: [{ color: "#bfbfbf" }] },
      { featureType: "road.highway", elementType: "geometry", stylers: [{ color: "#a6a6a6" }] },
      { featureType: "road.local", elementType: "geometry", stylers: [{ color: "#b0b0b0" }] },
      { featureType: "road", elementType: "labels.text.fill", stylers: [{ color: "#ffffff" }] },
      { featureType: "transit.line", elementType: "geometry", stylers: [{ color: "#9c9c9c" }] },
      { featureType: "transit.station", elementType: "geometry", stylers: [{ color: "#a8a8a8" }] },
      { featureType: "water", elementType: "geometry", stylers: [{ color: "#d6d6d6" }] }, 
      { featureType: "water", elementType: "labels.text.fill", stylers: [{ color: "#666666" }] }
    ],
  };
  
  // ===================== COLOR SCALES =====================
  function colorScale(v, min=0.0, max=10.0){
    if (v == null || isNaN(v)) return "#e0e0e0";
    const clamped = Math.max(min, Math.min(max, v));
    const t = (clamped - min) / (max - min);
    const hue = 0 + t * 120; // 0=red → 120=green
    return `hsl(${hue}, 100%, 50%)`;
  }
  
  function pointColor(v, min=0.0, max=10.0){
    if (v == null || isNaN(v)) return "#888";
    const clamped = Math.max(min, Math.min(max, v));
    const t = (clamped - min) / (max - min);
    const hue = 0 + t * 120;
    return `hsl(${hue}, 100%, 50%)`;
  }
  
  // ===================== HELPERS =====================
  function clamp01(x){ return Math.min(1, Math.max(0, x)); }
  
  //Transparency decreases with zoom:
  // when minZoom → maxOpacity, when maxZoom → minOpacity
  function opacityForZoomDown(zoom, cfg){
    const t = clamp01((zoom - cfg.minZoom) / (cfg.maxZoom - cfg.minZoom));
    return cfg.maxOpacity - t * (cfg.maxOpacity - cfg.minOpacity);
  }

  function fontPxForZoom(z, minPx = CFG.labels.minPx, maxPx = CFG.labels.maxPx){
    const z0 = CFG.labels.showFromZoom, z1 = 14; // by 14-th zoom maxPx is reached
    const t = Math.min(1, Math.max(0, (z - z0) / (z1 - z0)));
    return Math.round(minPx + t * (maxPx - minPx));
  }
  
  // ===================== MAP + LAYERS =====================
  let map, fylkeLayer, kommuneLayer, markers = [], labels = [];
  
  async function initMap(){
    const { Map } = await google.maps.importLibrary("maps");

    class BHLabel extends google.maps.OverlayView {
      constructor(position, text, fontPx) {
        super();
        this.position = position;
        this.el = document.createElement("div");
        this.el.className = "bh-label";
        this.setText(text);
        this.setFontPx(fontPx);
      }
      onAdd(){ this.getPanes().overlayMouseTarget.appendChild(this.el); }
      draw(){
        const p = this.getProjection(); if(!p) return;
        const pt = p.fromLatLngToDivPixel(this.position); if(!pt) return;
        this.el.style.position = "absolute";
        this.el.style.left = `${pt.x}px`;
        this.el.style.top  = `${pt.y}px`;
      }
      onRemove(){ if(this.el?.parentNode) this.el.parentNode.removeChild(this.el); }
      setText(t){ this.el.textContent = t; }
      setFontPx(px){ this.el.style.fontSize = `${px}px`; }
      setVisible(v){ this.el.style.display = v ? "block" : "none"; }
    }

    window.BHLabel = BHLabel;
  
    map = new Map(document.getElementById("map"), {
      center: {lat: 64.5, lng: 11.0},
      zoom: CFG.zoom.initial,
      styles: CFG.mapStyle
    });
  
    // Layers
    const styleFylke = f => {
      const id = f.getProperty("fylkesnummer") || f.getProperty("fylke_nr");
      const v = (typeof metricsFylke !== "undefined") ? metricsFylke[id] : undefined;
      const c = colorScale(v, 4.38, 4.6);      
      return {
        fillColor: c,
        fillOpacity: opacityForZoomDown(map.getZoom(), CFG.opacity.fylke),
        strokeColor: c,
        strokeWeight: CFG.poly.fylkeStroke,
        zIndex: 1
      };
    };
  
    const styleKommune = f => {
      const id = f.getProperty("kommunenummer") || f.getProperty("komm_nr");
      const v = (typeof metricsKommune !== "undefined") ? metricsKommune[id] : undefined;
      const c = colorScale(v, 3.3, 4.9);
      return {
        fillColor: c,
        fillOpacity: opacityForZoomDown(map.getZoom(), CFG.opacity.kommune),
        strokeColor: c,
        strokeWeight: CFG.poly.kommuneStroke,
        zIndex: 2
      };
    };
  
    fylkeLayer   = await addChoroplethLayer(CFG.urls.fylke,   styleFylke);
    kommuneLayer = await addChoroplethLayer(CFG.urls.kommune, styleKommune);
    kommuneLayer.setMap(null); // Hidden by default
  
    // Switching layers + refreshing styles on zoom
    map.addListener("zoom_changed", ()=>{
      const z = map.getZoom();
      if (z >= CFG.zoom.showKommunerFrom){
        fylkeLayer.setMap(null);
        kommuneLayer.setMap(map);
      } else {
        kommuneLayer.setMap(null);
        fylkeLayer.setMap(map);
      }
      // re-request styles (Data will apply styleFn again)
      fylkeLayer.setStyle(styleFylke);
      kommuneLayer.setStyle(styleKommune);


      //const z = map.getZoom();
      const show = z >= CFG.labels.showFromZoom;
      const fs = fontPxForZoom(z);
      for (const o of labels){
        o.setFontPx(fs);
        o.setVisible(show);
        o.draw(); // обновить позицию при движении
      }
    });
  
    // Points Barnehager as circles
    await addBarnehager();
  
    // Legend can be uncommunted if needed
    // buildLegend();
  }
  
  async function addChoroplethLayer(url, styleFn){
    const layer = new google.maps.Data({ map });
    const resp = await fetch(url, {cache:"no-store"});
    const gj = await resp.json();
    layer.addGeoJson(gj, { idPropertyName: "id" });
    layer.setStyle(styleFn);
  
    layer.addListener("mouseover", e => {
      layer.overrideStyle(e.feature, { strokeWeight: 2 });
      map.getDiv().style.cursor = "pointer";
    });
    layer.addListener("mouseout", e => {
      layer.revertStyle(e.feature);
      map.getDiv().style.cursor = "default";
    });
    layer.addListener("click", e => {
      const name = e.feature.getProperty("navn") || e.feature.getProperty("name");
      const val =
        (typeof metricsFylke !== "undefined" ? metricsFylke[e.feature.getProperty("fylkesnummer")] : undefined) ??
        (typeof metricsKommune !== "undefined" ? metricsKommune[e.feature.getProperty("kommunenummer")] : undefined);
      new google.maps.InfoWindow({
        content: `<b>${name ?? "Region"}</b><br/>Значение: ${val ?? "—"}`
      }).open({ map, position: e.latLng });
    });
  
    return layer;
  }
  
  async function addBarnehager(){
    const resp = await fetch(CFG.urls.barnehager, {cache:"no-store"});
    const items = await resp.json(); // [{lat,lng,name,value},...]
  
    for (const it of items){
      const circle = new google.maps.Circle({
        map,
        center: {lat: it.lat, lng: it.lng},
        radius: CFG.points.radiusM,               // in meters
        strokeWeight: CFG.points.strokeWeight,
        strokeColor: pointColor(it.value, 3, 5),  // gradient from red to green
        fillColor:   pointColor(it.value, 3, 5),
        fillOpacity: 0.9,
        zIndex: 1000
      });
      circle.addListener("click", ()=>{
        new google.maps.InfoWindow({
          content: `<b>${it.name ?? "Barnehage"}</b><br/>Value: ${it.value ?? "—"}`
        }).open({ map, position: {lat: it.lat, lng: it.lng} });
      });
      markers.push(circle);

      // подпись-значение поверх кружка
      const labelText = (typeof it.value === "number" && !Number.isNaN(it.value))
        ? it.value.toFixed(1) : "—";
      const z = map.getZoom();
      const overlay = new window.BHLabel(
        new google.maps.LatLng(it.lat, it.lng),
        labelText,
        fontPxForZoom(z)
      );
      // показать только с нужного зума
      overlay.setMap(map);
      overlay.setVisible(z >= CFG.labels.showFromZoom);
      labels.push(overlay);
      
    }
  }
  
  window.initMap = initMap;
</script>
</head>
<body>
  <div id="map"></div>
  <!--<div class="ctl">Wheel: Zoom · Click: Info</div>
  <div class="legend" id="legend">Legend</div>-->
  <script>
    /*function buildLegend(){
      const lg = document.getElementById("legend");
      const bins = [[0,5],[5,10],[10,15],[15,20],[20,Infinity]];
      for (const [a,b] of bins){
        const v = a===0 ? 4.9 : a+0.1;
        const c = (b===Infinity) ? colorScale(25) : colorScale(v);
        const label = (b===Infinity) ? `${a}+` : `${a}–${b}`;
        const row = document.createElement("div");
        row.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:${c};border:1px solid #aaa;margin-right:6px;"></span>${label}`;
        lg.appendChild(row);
      }
    }*/
  </script>
  
  <script defer src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.umd.js"></script>
  
  <script defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBAkTsDSCyrZ6zOdMuynDewilR2WpJFyKc&libraries=maps,marker&callback=initMap"></script>


</body>

</html>
